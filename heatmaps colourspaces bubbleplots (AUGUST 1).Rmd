---
title: "Course Notes: Heatmaps, Colour Spaces, and Bubble Plots With R"
subtitle: "Short Course (Virtual), ESA Meeting, Sunday, August 4, 2024, 1:00 pm - 4:00 pm (California Time)"
author: "Instructor and course notes author: Allan Roberts, robera64 at mcmaster.ca"
date: "Notes version: 2024-08-01"
output: 
  pdf_document:
    number_sections: yes
    toc: yes
    toc_depth: 3
fontsize: 12pt
---


\pagebreak  
  
 
# Introduction  
 
This short course will focus on tools for visualizing ecological data, using the statistics application R. Some topics to be covered include heatmaps, contour plots, and bubble plots. The core R package that we will be using for data visualization is ggplot2. One particular focus will be the effective and accessible use of colour in statistical graphics, based on a hue-chroma-luminance (HCL) colour space. This short course is intended to be of interest to those who have limited prior experience with R, as well as more experienced R users; this short course may also be valuable for those who have some experience with R but who are unfamiliar with the R package ggplot2. This short course aims to be useful and accessible for all ecologists, at any point in their career. As a free, flexible, and powerful statistics application and programming language, R can facilitate collaboration between working ecologists; R can also play an important part in the education of future ecologists. Using R for data analysis can help make data analysis workflows clear and reproducible.  
  
  
\pagebreak  
  
  
 
# R and R Packages   
  
Load some R package `ggplot2` (Wickham 2016) for data visualization:  
```{r}
library(ggplot2)
```


Load the R package `colorspace` (Zeileis et al 2020):
```{r}
library(colorspace)
```

Load the `metR` (Campitelli 2021) package for making labelled contour lines:  
```{r}
library(metR)
```

Load the R package `mgcv` (Wood 2017) for the `gam()` function:  
  
```{r}
suppressPackageStartupMessages(library(mgcv))
```



Load the `gridExtra` (Auguie 2017) package for the `grid.arrange()` function:
```{r}
library(gridExtra)
```

Load the `scales` (Wickham et al 2023) package for handling scales on data plots:  
```{r}
library(scales)
```

Load the R packages `sf` (Pebesma and Bivand 2023). and `sp` (Bivand et al 2013) for handling spatial data structures:  
```{r}
suppressPackageStartupMessages(library(sf))
library(sp)
```

Load the `maps` dataset for a map of the world:  
```{r}
library(maps)
```

Load the `dplyr` (Wickham et al 2023) function for data formatting:
```{r}
suppressPackageStartupMessages(library(dplyr))
```

Load the `cleveland.soil` dataset from the R package `agridat` (Wright 2024):
```{r}
data(cleveland.soil, package = "agridat")
```

Load the `lansing` dataset from the R package `spatstat.data` (Baddeley et al 2015):
```{r}
data(lansing, package = "spatstat.data")
```

(It seems that if you install the `spatstat` package, you also get the `spatstat.data` package.)  
  

\pagebreak  
  
  

**Installing R Packages**  

It should be possible to install these packages by using the `install.packages()` function. For example:  
  
```{r, eval = FALSE}
install.packages("maps")
```
\bigskip  
  
  
**Help Files**  
  
The `?` symbol can be used to get a help file for an R function or dataset. For example:  
```{r, eval = FALSE}
?histogram
```

The `library()` function can be used to get information about an R package. For example:  

```{r, eval = FALSE}
library(help = "scales")
```
 
\pagebreak  
  
  
  
# Bubble Plots  
  

## Plots with the `trees` Dataset  
  
Load the `trees` dataset from the R package `datasets`:  

```{r}
data(trees, package = "datasets")
```


View the first few rows of data:  

```{r}
head(trees, n = 4)
```

Make a scatterplot:  
```{r, fig.height = 3, fig.width = 4}
ggplot(trees) +
  geom_point(aes(x = Girth, y = Height))
```

The `ggplot()` layer specifies the dataset that is being used. Note that `ggplot2` typically requires that data be in the form of a data frame. A `geom` layer specifies a particular type (or *geometry*) of data plot; here `geom_point()` is used to give a scatterplot (i.e. a plot of scattered points). The `aes()` function specifies the `mapping` term, or how data values are mapped to visual (or *aesthetic*) attributes of the plot. Here `x = Girth` means that `Girth` variable is mapped to the horizontal position; the `y = Height` variable means that the `Height` variable is mapped to the vertical position.  
  


\pagebreak  
  
  
We can get a bubble plot by using a `size = Volume` term to map the data variable `Volume` to the size of the plotting characters:  
  
```{r, fig.height = 3, fig.width = 4}
ggplot(trees) +
  geom_point(aes(Girth, Height, size = Volume))
```
\bigskip  
  
  

We can use the `shape` and `colour` parameters to set the shape and the colour of the plotting symbols:  
  

```{r, fig.height = 3, fig.width = 4}
ggplot(trees) +
  geom_point(aes(Girth, Height, size = Volume), shape = 1, colour = "blue")
```

**Exercise.** Experiment with giving different values to the `shape` and `colour` parameters.  
  
**Exercise.** Make bubble plots with the `airquality` and `quakes` datasets, which are also found in the `datasets` package.  
  


\pagebreak  
  
  

 
## Adjusting the Scale for Size    
  
Set the seed for pseudorandom number generation:  
```{r}
set.seed(789)
```

Simulate values for three variables, and combine them into a data frame:  
```{r}
x <- runif(n = 200, min = 0, max = 1)
y <- runif(n = 200, min = 0, max = 1)
z <- rgamma(n = 200, shape = 3, scale = 1)

example_df <- data.frame(x, y, z)
```

Make a plot:  
  
```{r, fig.height = 4, fig.width = 4}
ggplot(example_df) +
  geom_point(aes(x, y, size = z), shape = 1) +
  coord_equal()
```


  
  
\pagebreak  
  
  
  

A `scale_size()` layer lets us control the scale for size. The `limits` argument sets the limits for the data values and the legend; the `range` parameter sets the lower and upper sizes for the plotting symbols.  
  
```{r, fig.height = 3.5, fig.width = 4}
ggplot(example_df) + coord_equal() +
  geom_point(aes(x, y, size = z), shape = 1, stroke = 0.3) +
  scale_size(limits = c(0, 12), range = c(0, 4), breaks = seq(0, 12, by = 2)) 
```
 
 
The `breaks` argument specifies the values that show up in the legend. An alternative to `scale_size()` is `scale_radius()`; you can find out more from the `?scale_size` help page.  
  
  
 
 
**Exercise.** Experiment with the `limits` and `range` argument for `scale_size()`.  
  
\pagebreak  
  
  
  
  
  
 
  
  
```{r, fig.height = 2.5, fig.width = 4, echo = FALSE, eval = FALSE}
example_df$w <- sample(0:4, size = nrow(example_df), replace = TRUE)

ggplot(example_df) + coord_equal() +
  geom_point(aes(x, y, size = w), shape = 1, stroke = 0.3) +
  scale_radius(limits = c(0, 4), range = c(0, 4)) +
  geom_text(aes(x, y, label = w, size = 0.75*w), show.legend = FALSE)
```

\pagebreak  
  
  
```{r, echo = FALSE, eval = FALSE}  
ggplot(example_df) +
  geom_point(aes(x, y, size = z), shape = 1) +
  coord_equal()
```  

\pagebreak  
  


  
## Mapping Data Values to Colour  
  
We can map the `z` values to colour by including the term `colour = z` inside the parentheses of the `aes()` mapping function:  
  
```{r, fig.height = 2.75, fig.width = 4}  
ggplot(example_df) + coord_equal() +
  geom_point(aes(x, y, size = z, colour = z), shape = 19) +
  theme(legend.box = "horizontal")
``` 

Note that we now have *two* legends. Also note that the two legends go in opposite directions (top to bottom vs. bottom to top). The `legend.box = "horizontal"` term in the `theme()` layer puts the two legends side-by-side, rather than one above the other.  
  
We can combine the two legends by matching the styles for the guides by using a `guides()` layer:  
  
  


```{r, fig.height = 2.75, fig.width = 4}  
ggplot(example_df) + coord_equal() +
  geom_point(aes(x, y, size = z, colour = z), shape = 19) +
  guides(colour = guide_legend(reverse = TRUE), 
         size = guide_legend(reverse = TRUE))
```

\pagebreak  
  
  
## A Multiple-Panel Bubble plot  

There are limits to how precisely size and colour can represent data values. For example, in the bubble plots that we have just made, we can probably read off approximate values for `x` and `y` more precisely than we would be able to for `z`. Because of the limitations of size and colour, we may sometimes want to augment or modify a bubble plot to make it more informative. One option is to use multiple panels.  

  
Use the `cut()` function to create a column for intervals of `z` values:  
```{r}
example_df$z_interval <- cut(example_df$z, breaks = 0:12)
```

Facet the data by the interval for `z`:  
```{r}
ggplot(example_df) +
  geom_point(aes(x, y, size = z, colour = z), shape = 1) +
  coord_equal() +
  guides(colour = guide_legend(reverse = TRUE), 
         size = guide_legend(reverse = TRUE)) +
  facet_wrap(~z_interval, labeller = "label_both") +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5))
``` 

\pagebreak  
  
  
  
## A Highly Patterned Dataset  
  
We will use the `rep()` function to generate a hypothetical dataset:  
  
```{r}
x <- rep(1:8, each = 8)
y <- rep(1:8, times = 8)
z <- rep(c(rep(2:1, times = 4), rep(1:2, times = 4)), times = 4)

example_df <- data.frame(x, y, z)
```

Make a pairwise scatterplot:  
  
```{r, fig.height = 4, fig.width = 4.5}
plot(example_df, asp = 1)
```

This pairwise scatterplot does not show how the value of `z` depends on the values of `x` and `y`. We cannot see a pattern that lets us know that `z` is strongly patterned based on the joint values of `x` and `y`.
 
  

Computing pairwise linear correlation coefficients likewise does not tell us much:  
  
  
```{r}
cor(x, z); cor(y, z); cor(x, y)
```

  
\pagebreak  
  
  
  
  
However, when we make a bubble plot, we can see that the dataset is strongly patterned:    

```{r, fig.height = 3, fig.width = 3.5}
ggplot(example_df) +
  geom_point(aes(x, y, size = z))
```

This example illustrates the idea that we might concievably miss patterns if we rely only on ordinary bivariate scatterplots.  
 
\bigskip  
  

We might dislike how some data symbols are so much smaller than others. We might feel that there are two many breakpoints in the legend (i.e. breakpoints corresponding to non-existant values). We can attempt to address these issues as follows:  



```{r, fig.height = 3, fig.width = 3.5}
ggplot(example_df) +
  geom_point(aes(x, y, size = z)) +
  scale_size_area(max_size = 4, breaks = c(1, 2))
```

\pagebreak  
  
  
```{r, fig.height = 3, fig.width = 3.5, echo = FALSE, eval = FALSE}
ggplot(example_df) +
  geom_point(aes(x, y, size = z), show.legend = FALSE) +
  theme_void() +
  coord_equal() +
  theme(panel.background = element_rect(fill = grey(0.95), colour = grey(0.95)))
```  

```{r, fig.height = 3, fig.width = 3.5, echo = FALSE, eval = FALSE}
ggplot(example_df) +
  geom_point(aes(x, y, size = z), show.legend = FALSE) +
  theme_void() +
  coord_equal()
```


\pagebreak  
  
  
  
## Bubble Plots with Base `graphics` Package

These notes focus on the R package `ggplot2`; however, it is possible to make a bubble plot with the ordinary `plot()` function from the base R `graphics` package. A drawback of the `plot()` function is that it will not automatically give us a scale (legend) for the size of the data symbols.   
  
  
  

Set the seed for pseudorandom number generation:    
```{r}
set.seed(789)
```

Generate some hypothetical data:  
```{r}
x <- runif(n = 100, min = 0, max = 1)
y <- runif(n = 100, min = 0, max = 1)
z <- rgamma(n = 100, shape = 3, scale = 1)
```



Set the plotting margins, and make a plot:  

```{r, fig.height = 4, fig.width = 4}
par(mar = c(4, 4, 1, 1))
plot(x, y, cex = z, asp = 1)
```

The argument `cex = z` maps the data variable `z` to the `cex` (character expansion) parameter. The `asp = 1` argument sets the aspect ratio for the plot.  
  
  
\pagebreak  
  
  
We can also map data values to a colour scale, using the `plot()` function; be we need to set up a colour scale ourselves; and once again, we do not automatically get a legend.  
  

Get values that are scaled between 0 and 1:  
```{r}
z_scaled <- (z - min(z))/(max(z) - min(z))
```

Exponentiate the scaled values:  
```{r}
z_scaled <- z_scaled^0.5
```

Use the `colorRamp()` function to define a colour palette function that transitions from blue to red, through grey:  
```{r}
pal <- colorRamp(c("blue", grey(0.5),  "red"))
```

Map each scaled `z` value to a colour:  
```{r}
colour <- rgb(pal(z_scaled), maxColorValue = 255)
```


Make a plot:  
```{r, fig.height = 3.5, fig.width = 3.5}
par(mar = c(4, 4, 1, 1))

plot(x, y, cex = z, bg = col2hcl(colour, alpha = 0.5), 
     asp = 1, pch = 21, col = "black", lwd = 0.5,
     ann = FALSE, axes = FALSE, frame = TRUE, xpd = NA)
```

The `col2hcl()` function from the R package `scales` has been used to make the data symbols semitransparent. We now have a coloured bubble plot, but we do not yet have a legend. It would not necessarily be very difficult to now add a legend using base `graphics` functions; however, this would be time consuming, and we can likely produce a bubble plot with a legend more efficiently by using the R package `ggplot2`.    

\pagebreak  
  
  
  
  

```{r, echo = FALSE, eval = FALSE}
**Exercise.** Make a plot like the following:  

x <- rep(1:8, each = 8)
y <- rep(1:8, times = 8)
z <- c(rep(rep(2:1, each = 4), times = 4), rep(rep(1:2, each = 4), times = 4 ))

example_df <- data.frame(x, y, z)

plot(example_df)

cor(example_df)
```


\pagebreak  
  


  
# Colour Names  
  
R recognizes many common colour names that we can use to set the colour of data plot features.  

Generate some hypothetical data:
```{r, fig.height = 3}
set.seed(2345)
x <- rnorm(100)
y <- rnorm(100)
```

Set up a pair of side-by-side plotting panels, and set the margin widths, and make a histogram and a scatterplot:
```{r, fig.height = 3}
par(mfrow = c(1, 2), mar = c(4, 4, 1, 1))

hist(x, col = "red", main = "")
plot(x, y, col = "blue")
```

To get a list of colour names that are recognized by R, enter `colors()` or `colours()` on the R command line:

```{r, eval = FALSE}
colours()
```

Will full saturation `"red"` often be the best colour for a histogram? Maybe not. If we want a reddish hue, we have other options, like `"rosybrown"`, `"peachpuff"`, and `"mistyrose"`. Or we might consider colours like `grey(0.95)` or `"azure"`.

\pagebreak  
  
 
Make similar types of plots with `ggplot2`:  
  
```{r, fig.height = 2.5, fig.width = 2.5}  
set.seed(234)

example_df <- data.frame(x = runif(400), y = runif(400), z = exp(rnorm(400)))

ggplot(example_df) + theme_bw() +
  geom_histogram(aes(x, y = after_stat(density)), 
                 fill = "azure", colour = "black", bins = 20,
                 linewidth = 0.25)

ggplot(example_df) + theme_bw() +
  geom_point(aes(x, y), colour = "steelblue", shape = 19, alpha = 0.5) +
  theme(panel.grid = element_blank())
```
\pagebreak  
  
  
## Setting Colour of `ggplot2` Theme Elements  
  
  
We can set the colours for theme (non-data) elements of a plot made with `ggplot2`:  
  
```{r, fig.height = 3.5, fig.width = 6.5, echo = FALSE, eval = FALSE} 
ggplot(example_df) +
  geom_point(aes(x, y, size = z), fill = "skyblue", shape = 21, colour = "white") +
  coord_equal() +
  theme(axis.text = element_text(colour = "rosybrown3")) +
  theme(axis.ticks = element_line(colour = "seagreen3")) +
  theme(axis.title.x = element_text(colour = "black")) +
  theme(panel.grid.major = element_line(colour = "skyblue3")) +
  theme(panel.grid.minor = element_line(colour = "cadetblue")) +
  theme(panel.background = element_rect(fill = "skyblue2")) +
  theme(plot.background = element_rect(fill = "skyblue1")) +
  theme(legend.key = element_rect(fill = "rosybrown3")) +
  theme(legend.background = element_rect(fill = "goldenrod")) +
  theme(legend.title = element_text(colour = "black")) +
  guides(size = guide_legend(override.aes = list(colour = "forestgreen", 
                fill = rep("darkorchid3", 1), linewidth = 3)))
```

  
  

```{r, fig.height = 3.25, fig.width = 6.5} 
ggplot(example_df) + coord_equal() +
  geom_point(aes(x, y, size = z), 
             fill = "forestgreen", shape = 21, colour = "white") +
  theme(axis.text = element_text(colour = "yellow")) +
  theme(axis.text.y = element_text(colour = "yellow")) +
  theme(axis.ticks = element_line(colour = "seagreen3")) +
  theme(axis.title.x = element_text(colour = "azure")) +
  theme(panel.grid.major = element_line(colour = "goldenrod3")) +
  theme(panel.grid.minor = element_line(colour = "green")) +
  theme(panel.background = element_rect(fill = "deepskyblue")) +
  theme(plot.background = element_rect(fill = "white")) +
  theme(legend.key = element_rect(fill = "mediumturquoise")) +
  theme(legend.background = element_rect(fill = "midnightblue")) +
  theme(legend.title = element_text(colour = "black")) +
  guides(size = guide_legend(override.aes = list(colour = "forestgreen", 
                fill = terrain.colors(9), linewidth = 3))) +
  scale_size(breaks = seq(4, 20, by = 2)) +
  theme(legend.key.width = unit(1, "mm"),
        legend.box.margin = unit(c(1, 1, 1, 1), "mm"))
```

**Discussion.** If we try to use colour to emphasize everything, we may end up by emphasizing nothing. Dark text on a dark background might not show up very well. Full saturation bright `"yellow"` may not be highly visible on a white background. If you want to use green a plot, full saturation bright `"green"` is not your only option. You may never need to use an  `override.aes` term in a `guides()` layer; but then again, who knows?      

\pagebreak  
  
  
Many of those same plot elements, for which we can set the colour, let us set attributes such as `linewidth`, `size`, and `angle`:
  
```{r, fig.height = 3.5, fig.width = 6.5} 
ggplot(example_df) +
  geom_point(aes(x, y, size = z), fill = "black", shape = 21, colour = "white") +
  coord_equal() +
  theme(axis.text = element_text(colour = "black", size = 12, angle = 45)) +
  theme(axis.ticks = element_line(linewidth = 2), axis.ticks.length = unit(5, "mm")) +
  theme(axis.title.x = element_text(angle = 45)) +
  theme(panel.grid.major = element_line(linewidth = 5)) +
  theme(panel.grid.minor = element_line(linewidth = 2)) +
  theme(panel.background = element_rect(fill = grey(0.3))) +
  theme(plot.background = element_rect(fill = grey(0.85))) +
  theme(legend.key = element_rect(linewidth = 1, colour = "black")) +
  theme(legend.background = element_rect(linewidth = 1)) +
  theme(legend.title = element_text(colour = "black")) +
  theme(plot.margin = unit(c(0.5, 0.5, 0.5, 0.5), "cm")) +
  ggtitle("plot title")
``` 

**Discussion.** Making a plot that is concurrently data-dense, uncluttered, and highly legible can take quite a bit of work. Sometimes we can improve a plot by making lines thinner, or by de-emphasizing, or even removing plot elements. Often we can make text more legible by making it larger, but then then we may need to adjust margins to make room for the text.  
  
  
  
**Hint.** By replacing a theme element with `element_blank()` we can remove that element from the plot.  
  
  
\pagebreak  
  
  
## Displaying a Colour with the `show_col()` Function  
  
  

The `show_col()` function from the R package `scales` can be a convenient way to display a colour:  
  
  
```{r, fig.height = 1, fig.width = 1}
show_col("azure")
```

\bigskip  
  
  
The `pal_grey()` function from the R package `scales` can be used to produce a grey scale:  
  

```{r, fig.height = 3, fig.width = 4}
show_col(pal_grey(0, 1)(12), cex_label = 0.8)
```

The `pal_brewer()` function is also in the `scales` package:  
  
  
```{r, fig.height = 3, fig.width = 4}
show_col(pal_brewer(palette = "Spectral")(10), cex_label = 0.8)
```


The `?palette.colors` help file will tell you about colour palettes that are predefined in R.  
  
  
\pagebreak  
  
  
  
   
## The `lansing` Dataset  


```{r, echo = FALSE, eval = FALSE}  
This example is intended to illustrate two main concepts: the careless application of a colour scale can lead to suboptimal data plots; the careful use of a colour scale can help us make better data plots.  
  
If we make better quality data plots, we cannot really expect the viewers of those data plots to thank us. Rather they may understand those plots and feel that they are clever, and that our results, whatever they are are too obvious to be noteworthy. Conversely, if we make poor quality data plots, the viewers of those plots will likely not blame us, they will simply be confused, and blame themselves. This state of affairs may, paradoxically, create a disincentive against the production of high quality data plots.  
```

Load the `lansing` dataset:    
```{r}
data(lansing, package = "spatstat.data")
```

Get an ordinary data frame that we can plot with `ggplot2`:  
```{r}
lansing_df <- data.frame(x = lansing$x, y = lansing$y, species = lansing$marks)
```

Make a plot:  
```{r}
ggplot(lansing_df) + coord_equal() +
  geom_point(aes(x, y, colour = species))
```


**Discussion.** Why might the default colour scale be a suboptimal choice for this data plot?  
  
  
  
 \pagebreak  
  


Using some other colour scale that merely seems convenient may not give us a result that is any better:  

  
```{r}
lansing_df <- data.frame(x = lansing$x, y = lansing$y, species = lansing$marks)

pal <- c("cyan", "yellow", "magenta", "blue", "red", "green")

ggplot(lansing_df) + coord_equal() +
  geom_point(aes(x, y, colour = species)) +
  scale_colour_manual(values = pal)
```


  
\pagebreak  



We can try to improve the plot by carefully choosing colours, and augmenting the colours with shapes:   
  
```{r}
pal <- c("blackoak" = "black", "redoak" = "firebrick3", "whiteoak" = "beige",
         "hickory" = "seagreen3", "maple" = "darkorange", "misc" = "black")


shape_scale <- c("blackoak" = 21, "redoak" = 21, "whiteoak" = 21,
         "hickory" = 22, "maple" = 24, "misc" = 3)

ggplot(lansing_df) + coord_equal() +
  geom_point(aes(x, y, fill = species, shape = species), size = 2) +
  scale_fill_manual(values = pal) +
  scale_shape_manual(values = shape_scale)
```   
\pagebreak  
  
  
 
Plotting symbol colour and shape can only so much. Sometimes we might want a multiple-panel data plot.  
  

```{r}
pal <- c("blackoak" = "black", "redoak" = "firebrick3", "whiteoak" = "beige",
         "hickory" = "seagreen3", "maple" = "darkorange", "misc" = "black")


shape_scale <- c("blackoak" = 21, "redoak" = 21, "whiteoak" = 21,
         "hickory" = 22, "maple" = 24, "misc" = 3)

ggplot(lansing_df) + coord_equal() +
  geom_point(aes(x, y, fill = species, shape = species), size = 2) +
  scale_fill_manual(values = pal) +
  scale_shape_manual(values = shape_scale) +
  facet_wrap(~species) +
  theme(strip.background = element_rect(fill = "transparent", colour = grey(0.5)),
        strip.text = element_text(size = 14), legend.position = "none") +
  xlab(NULL) + ylab(NULL)
```   

Now that each species is shown in a different facet, it might be the case that the shape and colour scales are no longer necessary; we might therefore consider (for example) plotting all the data with open circles (`shape = 1`).

\pagebreak  
  
   
  
  
  
# Colour Spaces  

We will look at the red-green-blue (RGB) and hue-chroma-luminance (HCL) colourspaces. We will see how colour spaces can be used in the construction of colour palettes, and how colour palettes can be used in colour scales for plots such as heatmaps, and bubble plots that map data values to both size and colour.  
  
   
  
## The Red-Green-Blue Colour Space    

The `rgb()` function can specify a plotting colour by setting its red, green, and blue components.  
  
  
```{r, fig.height = 3, fig.width = 3}
x <- rnorm(100)
y <- rnorm(100)

par(mar = c(4, 4, 1, 1))
plot(x, y, col = rgb(0, 0, 1), asp = 1)
```
```{r, fig.height = 5/3, fig.width = 5}
par(mfrow = c(1, 3), mar = c(1, 1, 1, 1))
plot(x, y, col = rgb(1, 0, 0), ann = FALSE, axes = FALSE, frame = TRUE)
plot(x, y, col = rgb(0.3, 1, 0), ann = FALSE, axes = FALSE, frame = TRUE)
plot(x, y, col = rgb(0, 0.5, 0.5), ann = FALSE, axes = FALSE, frame = TRUE)
```
  
  
**Exercise.** Try out different values for the red, green, and blue components.  
  

  



\pagebreak  
  
  
  

  
Make a data frame with columns for the red, green, and blue components:  
  
```{r}
rgb_df <- expand.grid(red = seq(0.1, 0.9, by = 0.1), 
                green = seq(0.1, 0.9, by = 0.1), blue = seq(0.1, 0.9, by = 0.1))
```

Use the `rgb()` function to add a column for the colour:
```{r}
rgb_df$colour <- rgb(rgb_df$red, rgb_df$green, rgb_df$blue)
```

Make a plot:  
  
```{r}
ggplot(rgb_df) + theme_minimal() + coord_equal() +
  geom_point(aes(red, green, colour = colour)) +
  facet_wrap(~blue, labeller = "label_both") +
  scale_colour_identity() +
  theme(panel.grid = element_blank()) +
  scale_x_continuous(breaks = seq(0, 1, by = 0.2)) +
  scale_y_continuous(breaks = seq(0, 1, by = 0.2))
```  


**Hint.** The `col2rgb()` function will give you the red, green, and blue colour components for an R colour name:  

```{r, eval = FALSE}
col2rgb("blue")/255
```

Here we have divided by 255 to convert from a 0 to 255 scale to a 0 to 1 scale.  
  
  

\pagebreak  
  
  

  

## The Hue-Chroma-Luminance Colour Space  
  
Although it is possible to construct a colour scale by directly using the red-green-blue (RGB) colour space, it can be difficult to do so. We might find it easier to construct a useful colour scale by using the hue-chroma-luminance (HCL) colour space. Loosely speaking, *hue* corresponds to the position of a colour in the visual spectrum (e.g. red, orange, yellow, green, blue, violet), *chroma* corresponds to the vividness or saturation of a colour (e.g. colourful vs. colourless), and *luminance* corresponds to the brightness (bright vs. dark).  
  


```{r, echo = FALSE}
suppressPackageStartupMessages(library(grid))
```

```{r, eval = FALSE}
library(scales)
```

Produce a colour that is reddish (hue = 0), pale (chroma = 30), and bright (luminance = 85):  
  
```{r, fig.height = 1, fig.width = 3}
show_col(hcl(h = 0, c = 30, l = 85, fixup = FALSE))
```

Produce a colour that is bluish (hue = 250), saturated (chroma = 60), and dark (luminance = 35):  
  
```{r, fig.height = 1, fig.width = 3}
show_col(hcl(h = 250, c = 60, l = 35, fixup = FALSE))
```

Produce a colour that is greenish (hue = 120), saturated (chroma = 110), and bright (luminance = 90):  
  
```{r, fig.height = 1, fig.width = 3}
show_col(hcl(h = 120, c = 110, l = 90, fixup = FALSE))
```

\pagebreak  
  
  
  
It may not be obvious how to express a colour name in HCL coordinates. We can convert an R colour name into HCL coordinates with the help of the R package `colorspace`.  
  
  
This syntax translates the colour name `"blue"` into HCL coordinates:  

```{r}
library(colorspace)
as(sRGB(t(col2rgb("blue")/255)), "polarLUV")
```

The `col2rgb()` function translates the colour name `blue` into red-green-blue coordinates. The `sRGB()` gives us an `sRGB` object as used by the `colorspace` package. The `as(., "polarLUV")` function converts from RGB coordinates to HCL coordinates.  
  

Check that these coordinates actually give us the R colour `"blue"`:  
```{r, fig.height = 1, fig.width = 1}
show_col(hcl(h = 265.8728, c = 130.6759, l = 32.29567, fixup = FALSE))
```  
  
  
Another difficulty associated with the HCL colour space is that not every sensible looking specification of hue, chroma, and luminance values gives us a valid colour that can be produced on the computer screen.

```{r, fig.height = 1, fig.width = 1}
show_col(hcl(h = 260, c = 80, l = 20, fixup = FALSE))
```  

A quick fix can be to use the parameter setting `fixup = TRUE`, however doing so means that the HCL coordinates may only be approximate:
```{r, fig.height = 1, fig.width = 1}
show_col(hcl(h = 260, c = 80, l = 20, fixup = TRUE))
```  

\pagebreak  
  
We can illustrate the HCL colour space with a colour wheel diagram.  
  
Set up a data frame with columns for `hue` and `luminance` values:  
```{r, dev = "png", fig.height = 3.5, fig.width = 3.5}
hcl_df <- expand.grid(hue = seq(0, 360, by = 1), luminance = seq(0, 100, by = 2))
```


Compute a column of `chroma` values as half of the maximum attainable chroma at each combination of `luminance` and `hue` values:  
```{r}
hcl_df$chroma <- 0.5 * max_chroma(l = hcl_df$luminance, h = hcl_df$hue)
```

Get a column of hexidecimal colour specifications:  
```{r}
hcl_df$colour <- hcl(hcl_df$hue, hcl_df$chroma, hcl_df$luminance, fixup = FALSE)
```


Make a plot using polar coordinates:  
  
```{r, dev = "png", fig.height = 3.5, fig.width = 3.5}
pA_base <- ggplot(hcl_df) + 
  geom_point(aes(hue, luminance, colour = colour), na.rm = TRUE, shape = 19) +
  scale_colour_identity() +
  coord_polar()
  
print(pA_base)
```
\pagebreak  
  
  

We can make the diagram more informative by adding labels.  
  
Define a vector of the colours we want to label:    
```{r}
s <- c("red", "green", "blue", "orange", "yellow", "cyan", "magenta")
```

Compute positions in terms of hue for the labels:  
```{r}
h <- colorspace::coords(as(sRGB(t(col2rgb(s)/255)), "polarLUV"))[,"H"]
```

```{r, fig.height = 4}
pA <- ggplot(hcl_df) + theme_bw() +
  geom_point(aes(hue, luminance, colour = colour), na.rm = TRUE, shape = 19) +
  scale_colour_identity() +
  scale_x_continuous(breaks = c(h, seq(0, 300, 60)), labels = c(s, seq(0, 300, 60))) +
  scale_y_continuous(breaks = seq(0, 100, by = 25), limits = c(0, 110)) +
  geom_vline(xintercept = h, linetype = "dashed") +
  theme(panel.background = element_rect(fill = "black")) +
  theme(axis.text.x = element_text(colour = "white", size = 12, vjust = -5), 
        axis.text.y = element_text(colour = "black")) +
  theme(panel.grid = element_blank()) +
  coord_polar(theta = "x" ) +
  annotate(geom = "text", x = c(0, 0), y = c(10, 90), 
           label = c("low luminance", "high luminance"), colour = c("white", "black"))
  
print(pA)
```


```{r, echo = FALSE}
hcl_df1 <- hcl_df
```

\pagebreak  
  
  
If we look closely at the previous plot, we can see that the saturation of the colour is somewhat uneven; this is associated with the maximum attainable chroma being dependent on the hue and luminance.  
  
We can show the values for chroma by adding contour lines:  
  
```{r}
pC <- ggplot(hcl_df) + theme_bw() +
  geom_point(aes(hue, luminance, colour = colour), na.rm = TRUE, shape = 19) +
  scale_colour_identity() +
  scale_x_continuous(breaks = c(h, seq(0, 300, 60)), labels = c(s, seq(0, 300, 60))) +
  scale_y_continuous(breaks = seq(0, 100, by = 25), limits = c(0, 110)) +
  coord_polar(theta = "x" ) +
  theme(panel.background = element_rect(fill = "black")) +
  theme(axis.text.x = element_text(colour = "white", size = 12, vjust = -5), 
        axis.text.y = element_text(colour = "black")) +
  theme(panel.grid = element_blank()) +
  geom_contour2(aes(hue, luminance, z = chroma, label = after_stat(level)), 
                colour = "black")

print(pC)

```
\pagebreak  
  
  
  

# Heatmaps  
  
  
## Example: A Soil Dataset  
  
  
  
We will use the `cleveland.soil` dataset from the R package `agridat`:
```{r}
data(cleveland.soil, package = "agridat")
```

The `?cleveland.soil` help file cites the book *Visualizing Data* (Cleveland, 1993); that book uses this dataset in an example.  


Make a plot the maps the variable `resistivity` to colour:  
  
```{r}
ggplot(cleveland.soil) +
  geom_point(aes(northing, easting, colour = resistivity)) +
  coord_equal() +
  scale_x_reverse()
```

The `coord_equal()` layer puts units of easting and units of northing on the same scale. Here `easting` is placed on the horizontal axis simply to let the plot fit nicely on the page. The `scale_x_reverse()` layer makes the `northing` axis go from right to left, so that the map looks correct if we rotate the page 90 degrees.  
  

\pagebreak  
  
  
  
An alternative to using a colour scale is to make a bubble plot:  
  
```{r}
ggplot(cleveland.soil) + theme_bw() +
  geom_point(aes(northing, easting, size = resistivity), shape = 1,
             stroke = 0.1) +
  coord_equal() + scale_x_reverse() +
  scale_size(range = c(0, 3)) +
  theme(legend.position = "bottom")
```

\pagebreak  
  
  

We might want to interpolate the resistivity value to locations without observations.  
  
Use the `gam()` function from the R package `mgcv` to fit a two-dimensional thin-plate spline to the observations:  
  
```{r}
library(mgcv)
model_gam <- gam(resistivity ~ s(easting, northing), data = cleveland.soil, 
                 gamma = 0.1)
```

The default setting is `gamma = 1`. Here we are using `gamma = 0.1` to reduce the penalty for wiggliness in the surface, allowing the fitted surface to fit the data more closely. 



Set up a grid of locations where we want fitted values:  
  
  
```{r}
newdata <- expand.grid(easting = seq(0, 1.55, by = 0.05), 
                       northing = seq(0, 3.8, by = 0.05))
```


Get fitted values:  
```{r}
newdata$fit_gam <- predict(model_gam, newdata = newdata)
```


Define two colour palettes:
```{r}
palA <- cm.colors(n = 20)
palB <- diverge_hcl(n = 20)
```

  
  
  

Make a pair of plots using the two different colour scales:  
  
```{r}
pA <- ggplot(newdata) +
  geom_raster(aes(northing, easting, fill = fit_gam)) +
  coord_equal() +
  scale_x_continuous(expand = c(0, 0)) +
  scale_y_reverse(expand = c(0, 0)) +
  scale_fill_gradientn(colours = palA) +
  geom_contour2(aes(northing, easting, z = fit_gam, label = after_stat(level))) +
  labs(tag = "A")

pB <- ggplot(newdata) +
  geom_raster(aes(northing, easting, fill = fit_gam)) +
  coord_equal() +
  scale_x_continuous(expand = c(0, 0)) +
  scale_y_reverse(expand = c(0, 0)) +
  scale_fill_gradientn(colours = palB) +
  geom_contour2(aes(northing, easting, z = fit_gam, label = after_stat(level))) +
  labs(tag = "B")
```


  
  

\pagebreak  
  
  
  

Display the plots:  
```{r, dev = "png"}
grid.arrange(pA, pB, nrow = 2)
```

Note that the labelled contour lines are very helpful for the interpretation of the plot. We may sometimes see heatmaps without contour lines, or contour lines without labels. Often it may be possible to improve such plots by using labelled contour lines. The colour scale may be most useful for giving us a fast overview of the general shape of the surface, while the labelled contour lines are useful for allowing the reading off of exact values.  
  
It is the `geom_contour2()` layer, made possible by the R package `metR` that makes the labels on the contour lines possible.  

 
\pagebreak  
  
  
The `diverge_hcl()` function allows us to set the hue for the endpoints of a colour scale:  
  
  
```{r}
palC <- diverge_hcl(n = 20, h = c(100, 60))
palD <- diverge_hcl(n = 20, h = c(192, 308))
```



We can use the `%+%` symbol to update a previous plot:  
  
  
```{r, dev = "png"}
pC <- pA %+% scale_fill_gradientn(colours = palC) %+% labs(tag = "C")
pD <- pA %+% scale_fill_gradientn(colours = palD) %+% labs(tag = "D")
grid.arrange(pC, pD, nrow = 2)
```


\pagebreak  
  
  
  




  

## Example: A Simulated Dataset  
  
To generate a smooth surface, we will generate some pseudorandom data points, and then fit a two-dimensional smooth surface through the points using the `gam()` function from the R package `mgcv`. We will then generate colour palettes using the RGB colourspace, and make heatmaps to illustrate those colour palettes.   
  
Generate some pseudorandom simulated observations:  
  
```{r, fig.height = 3.75, fig.width = 4.5}
set.seed(123)
example_df <- 
  expand.grid(x = seq(0, 1, length.out = 101), y = seq(0, 1, length.out = 101))

example_df$z <- rnorm(nrow(example_df))
```


Fit a smoother through the pseudorandom observations:  
  
```{r}
model_gam <- gam(z ~ s(x, y), gamma = 0.1, data = example_df)
example_df$fit <- predict(model_gam)
```

The `vis.gam()` function gives us a convenient way to display the fitted surface:  
  
  
```{r, fig.width = 3.5, fig.height = 3.5}
vis.gam(model_gam, color = "bw", plot.type = "contour", type = "response", asp = 1)
```
\pagebreak  
  
  
  
We can also display the fitted surface with `ggplot2`:  
  
```{r, fig.height = 4, fig.width = 4}
breaks <- round(seq(-1, 1, by = 0.02), digits = 3)

p_contour<- ggplot(example_df) + theme_minimal() +
    theme(panel.grid = element_blank()) +
    geom_contour2(aes(x, y, z = fit, label = after_stat(level)), 
                  breaks = breaks, colour = "black") +
  coord_equal() +
  scale_x_continuous(expand = c(0, 0)) + scale_y_continuous(expand = c(0, 0)) +
  labs(x = "", y = "") + theme(legend.position = "right") 


print(p_contour)
```

Note that `geom_contour2()` is provided by the `metR` package.  
  

\pagebreak  
  
  
  
Now we will add colour to the plot. To reduce the total amount of R syntax, we will make a base plot `p_base`, and then add different colour scales to that base plot using the `%+%` symbol.  
  

```{r, dev = "png", fig.height = 6.5/2}
p_base <- ggplot(example_df) +
    geom_raster(aes(x, y, fill = fit)) +
    geom_contour2(aes(x, y, z = fit), breaks = breaks, colour = "white") +
  coord_equal() +
  scale_x_continuous(expand = c(0, 0)) + scale_y_continuous(expand = c(0, 0)) +
  labs(x = "", y = "") + theme(legend.position = "right") 
```

Define a colour palette using the `rgb()` function:  

```{r}
R <- seq(0, 0.85, length.out = 20)^(1/3)
pal0 <- rgb(R, R, 0.85)
```


Add two different colour scales to the base plot:  
  
```{r, fig.height = 6.5/2}
p1 <- p_base %+% scale_fill_gradientn(colours = pal0)
p2 <- p_base %+% scale_fill_gradientn(colours = sequential_hcl(20, h = 265, power = 3))

grid.arrange(p1, p2, ncol = 2)
```
We have used RGB coordinates to define a colour scale that is fairly similar to what we can get from the `sequential_hcl()` function from the `colorspace` package. Generally speaking, it will be easier get useful colour scales by using functions from the `colorspace` package, rather then trying to define our own colour scales from scratch.  
  

\pagebreak  
  
  
  
It may be possible to produce fairly sensible colour palettes by directly using the `rgb()` function; however, this can be rather awkward. Here are more examples:   
  
  
```{r}
R <- seq(0, 1, length.out = 20)^(1/3); B <- seq(1, 0, length.out = 20)^(1/3)
palA <- rev(rgb(R, g = pmin(R, B), B))

R <- seq(0, 1, length.out = 20)^(1/3); B <- seq(1, 0, length.out = 20)^(1/3)
palB <- rev(rgb(R, pmax(R, B), B))

R <- seq(0, 1, length.out = 20)^(1/3); B <- seq(1, 0, length.out = 20)^(1/3)
palC <- rgb(R, (R - B)^2, B)

R <- seq(0, 1, length.out = 20)^(1/3); B <- seq(1, 0, length.out = 20)^(1/3)
palD <- rgb(R, 1 - (B - R)^2, B)

p0 <- p_base %+% scale_fill_gradientn(colours = pal0)
pA <- p_base %+% scale_fill_gradientn(colours = palA)
pB <- p_base %+%  scale_fill_gradientn(colours = palB)
pC <- p_base %+%  scale_fill_gradientn(colours = palC)
pD <- p_base %+%  scale_fill_gradientn(colours = palD)
```

```{r}
grid.arrange(p0, pA, pB, pD,  ncol = 2)
```

\pagebreak  
  

  
  
## Example: `phytools`  
  
This example basically just intends to point out that the `phylo.heatmap()` function from the R package `phytools` (Revell 2024) provides a way to make multivariate phylogenetic heatmaps.   
  
This blog post gives an example:  
  
http://blog.phytools.org/2016/01/new-function-for-phylogenetic-heat-map.html

Here is simple example that has been adapted from that blog post:

```{r, fig.height = 5}
suppressPackageStartupMessages(library(phytools))
tree <- pbtree(n = 12, tip.label = letters[1:12])
pal <- colorspace::diverge_hcl(10)
M <- matrix(rnorm(60), 12, 5)
rownames(M) <- tree$tip.label
par(mar = c(7, 7, 4, 4))
phylo.heatmap(tree, M, col = pal)
```
\pagebreak  
  


## Example: Sugar Availability Data  
  
We will use data for per capita availability of refined sugar (g/day) for an example of a geographic heatmap. This example uses the `sf`, `sp`, `maps` and `dplyr` packages.   
  
Get some map data:   
  
```{r}
world_map <- map_data("world")
class(world_map)
```

Create an `sf` data frame: 

```{r, fig.height = 2.5}
xy_points <- SpatialPoints(cbind(world_map$long, world_map$lat))
xy_points <- st_as_sfc(xy_points)

ids <- world_map$group

xy_multipoint <- st_cast(xy_points, to = "MULTIPOINT", ids = ids)
xy_polygon <- st_cast(xy_multipoint, to = "POLYGON")

polygon_sf <- st_sf(data.frame(geometry = xy_polygon, group = unique(ids)))

world_map_summary <- summarize(group_by(world_map, group, region, subregion), 
                               .groups = "keep")

polygon_sf <- left_join(polygon_sf, world_map_summary, by = "group")

ggplot(polygon_sf) +
  geom_sf()
```


There ought to be an easier way to transform the `maps` package data frame into an sf data frame. The point of all the syntax here is simply that we want to get the data frame from the `maps` package into a format we can plot with a `geom_sf()` layer in `gpplot2`.  

\pagebreak  
  
  
  
  
This data is a subset of the WHO dataset available online.

Data source: 

\footnotesize

https://www.who.int/data/gho/data/indicators/indicator-details/GHO/ORALHEALTH_SUGAR_AVAILABILITY

\normalsize  
  
  
The subset of data values included here is very haphazard. One complicating issue is that many of the country names in the WHO dataset do not exactly match the country names in the world map dataset in the `maps` package.

```{r, fig.height = 3.5}
region_subset <- c("Germany", "Mauritania", "Chile", "Thailand", 
                   "Central African Republic", "Madagascar", "Chad", 
                   "Ethiopia", "Nigeria", "Mongolia", "Angola", "Zambia", 
                   "Mali", "Mozambique", "Turkmenistan", "Afghanistan", 
                   "Kenya", "Uzbekistan", "Peru", "Pakistan", "Botswana", 
                   "Namibia", "Democratic Republic of the Congo", "Egypt", 
                   "Norway", "Libya", "Sudan", "Finland", "Myanmar", 
                   "South Africa", "Saudi Arabia", "Colombia", "Spain", 
                   "Morocco", "Sweden", "Mexico", "Canada", "France")

value_subset <- c(100.6, 101.2, 117.1, 117.3, 14.6, 20.2, 24.3, 26, 
                  27, 27.3, 30.9, 32.5, 32.7, 34, 46.5, 46.8, 47.3, 53.5, 
                  54.7, 57.7, 62.3, 62.4, 7.4, 70.9, 74.4, 77.1, 77.3, 
                  79.8, 8.5, 82.1, 82.9, 88.1, 89.4, 91.8, 92.4, 
                  93.9, 94.5, 97.5)

sugar_data <- data.frame(region = region_subset, Value = value_subset)
```


Combine the sugar data with the map data:  
```{r}
polygons_sf_small <- left_join(polygon_sf[,c("region")], sugar_data, by = "region")
```

There is a `plot` method for `sf` objects:  
```{r}
# Not run:
# plot(polygons_sf_small[, "Value"])
```
\pagebreak  
  
  

Now that we have an `sf` data frame with a column of data values, we can make a heatmap using `ggplot2`:
```{r}
ggplot(polygons_sf_small) +
  geom_sf(aes(fill = Value)) 
```


```{r}
pal <- colorspace::diverge_hcl(n = 20, h = c(265, 10))

ggplot(polygons_sf_small) +
  geom_sf(aes(fill = Value)) +
  scale_fill_gradientn(colours = pal)
```


**Exercise.** Experiment with different colour scales.  
  
**Discussion.** How could we make such a plot more informative?

\pagebreak  
  
  
  




  
**References and R packages**  

Auguie, B., 2017. gridExtra: Miscellaneous Functions for "Grid" Graphics. R package version 2.3.

Baddeley, A., E. Rubak, R. Turner, 2015. Spatial Point Patterns: Methodology and Applications with R. Chapman
  and Hall/CRC Press, London. (Citation for the R package `spatstat`.) 
  
Becker, R. A., and A. R. Wilks (Original S code), R version by Ray Brownrigg, with enhancements by Thomas P Minka and Alex Deckmyn, 2023. maps: Draw Geographical Maps. R package version 3.4.2.

Campitelli, E., 2021. metR: Tools for Easier Analysis of Meteorological Fields. R package version 0.15.0.

Cleveland, W. S., 1993. Visualizing Data. Publisher	AT&T Bell Laboratories. Original from	the University of Michigan.

Pebesma, E., R. Bivand, 2023. Spatial Data Science: With Applications in R. Chapman and Hall/CRC. (A citation for the R package `sf`.)

Pebesma, E., 2018. Simple Features for R: Standardized Support for Spatial Vector Data. The R Journal
10 (1), 439-446. (Another citation for the R package `sf`.)

Revell, L. J., 2024. phytools 2.0: an updated R ecosystem for phylogenetic comparative methods (and other things). PeerJ, 12, e16505.  
  
Wickham, H. ggplot2: Elegant Graphics for Data Analysis. Springer-Verlag New York, 2016.  

Wickham, H., R. François, L. Henry, K. Müller, D. Vaughan, 2023. dplyr: A Grammar of Data Manipulation.
  R package version 1.1.4.

Wickham, H., T. Pedersen, D. Seidel, 2023. scales: Scale Functions for Visualization. R package
  version 1.3.0.

Wood, S. N., 2017. Generalized Additive Models: An Introduction with R (2nd edition). Chapman and Hall/CRC.
  
Wright, K., 2024. agridat: Agricultural Datasets. R package version 1.23.

Zeileis, A., J. C. Fisher, K. Hornik, R. Ihaka, C. D. McWhite, P. Murrell, R. Stauffer, C. O. Wilke, 2020.
  colorspace: A Toolbox for Manipulating and Assessing Colors and Palettes. Journal of Statistical
  Software, 96 (1), 1-49.

Zeileis, A., K. Hornik, P. Murrell, 2009. Escaping RGBland: Selecting Colors for Statistical Graphics.
  Computational Statistics & Data Analysis, 53(9). (Another citation for the R package `colorspace`.)


