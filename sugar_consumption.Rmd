---
title: "Heatmaps, Colour Spaces, and Bubble Plots With R"
subtitle: "Examples with WHO Sugar Availability Dataset"
output: pdf_document
date: "2024-05-16"
author: "AJR"
fontsize: 12pt
toc: yes
header-includes: \usepackage{float}
---

```{r, echo = FALSE}
knitr::opts_chunk$set(fig.pos = 'H')
```

\pagebreak  
  
  
  

# Introduction  
  
This material may be of use for this short course:  
  
  
Session Date / Time:	8/4/2024, 1:00 pm - 4:00 pm (California Time)  
Title:	Heatmaps, Colour Spaces, and Bubble Plots With R  

\bigskip  
  
  

The term *heatmap* may mean different things to different people. Some people may strongly associate the term with bioinformatics. Generally speaking, we are interested in cases where we have an x- variable and an y- variable plotted to the horizontal and vertical axes, and a third variable that is plotted  to colour. We can also include cases where spatial polygons are plotted to colour of fill; such plots seems to be popular (and some people may strongly associate the term *map* with a geographic map).  
  
We might call a scatterplot that maps a third variable to colour a *confetti plot*; the term *confetti plot* does not yet seem to be in general use.  

  
  
\pagebreak  
  
  
  
Load some R packages:  
  
```{r}
suppressPackageStartupMessages(library(sf))
library(sp)
library(ggplot2)
library(maps)
suppressPackageStartupMessages(library(dplyr))
library(ggrepel)
suppressPackageStartupMessages(library(gridExtra))
library(stringr)
```

\pagebreak  
  
  
# Draw a Map of the World  
 
 

Get some map data:   
  
```{r}
world_map <- map_data("world")
class(world_map)
```

Create an sf dataframe: 
```{r, echo = TRUE, eval = FALSE}
# A better way of converting to an sf data frame ought to be possible.

# Perhaps a better method:
XY <- st_sfc(st_multipoint(cbind(world_map$long, world_map$lat)))
XY <- st_cast(XY, "POINT")

# XY <- st_cast(XY, ids = world_map$group, group_or_split = TRUE)

# XY <- st_cast(XY, "MULTIPOINT")

#XY <- st_cast(XY, "POINT")
#XY <- st_cast(XY, "MULTIPOINT", ids = world_map$group, group_or_split = TRUE)

# XY <- st_cast(XY, "POLYGON")

# world_map2 <- world_map

world_map2$geometry <- XY 


world_map2 <- reframe(group_by(world_map2, group, region, subregion), 
                        geometry = st_cast(geometry, to = "MULTIPOINT"))
# class(world_map2$geometry)

world_map2 <- st_sf(world_map2)

world_map2$geometry <- st_sf(st_cast(world_map2, "MULTILINESTRING"))


ggplot(world_map2) +
  geom_sf()
```

```{r}
xy_points <- SpatialPoints(cbind(world_map$long, world_map$lat))
xy_points <- st_as_sfc(xy_points)

ids <- world_map$group

xy_multipoint <- st_cast(xy_points, to = "MULTIPOINT", ids = ids)
xy_polygon <- st_cast(xy_multipoint, to = "POLYGON")

polygon_sf <- st_sf(data.frame(geometry = xy_polygon, group = unique(ids)))

# Not run:
# plot(polygon_sf)

ggplot(polygon_sf) +
  geom_sf()
```

It seems that there ought to be an easier way to transform the `maps` package data frame into an sf data frame.  
  


\pagebreak  
  
  
# Heatmaps  
  

## Combine Data with the Map  
  
  
Combine the sugar data with the map data:  
  


```{r, fig.cap = "Many of the missing values are due to mismatches in region names.", out.extra = ""}

world_map_summary <- summarize(group_by(world_map, group, region, subregion), 
                               .groups = "keep")

polygon_sf <- left_join(polygon_sf, world_map_summary, by = "group")


sugar_data <- read.csv("WHO_sugar_data.csv")


sugar_data$region <- sugar_data$Location


polygon_sf <- left_join(polygon_sf, sugar_data[,c("region", "Value")], 
                        by = "region")

ggplot(polygon_sf) +
  geom_sf(aes(fill = Value)) 
```
\pagebreak  
  



## Standardizing Country Labels  
  
  
  
Several of the `region` names in the map data do not match the `Location` names in the sugar data. Will will fix some of these mismatches manually.  
  
  
  
```{r}  
sugar_data[sugar_data$Location == "United States of America",]$region <- 
  "USA"

sugar_data[sugar_data$Location == 
    "United Kingdom of Great Britain and Northern Ireland",]$region <- "UK"

sugar_data[sugar_data$Location == "Russian Federation",]$region <- "Russia"

sugar_data[sugar_data$Location =="Bolivia (Plurinational State of)",]$region <- 
  "Bolivia"

sugar_data[sugar_data$Location ==
             "Venezuela (Bolivarian Republic of)",]$region <-
  "Venezuela"


sugar_data[sugar_data$Location =="TÃ¼rkiye",]$region <- "Turkey" 

sugar_data[sugar_data$Location =="Czechia",]$region <-  "Czech Republic" 

sugar_data[sugar_data$Location =="Viet Nam" ,]$region <-  "Vietnam" 

sugar_data[sugar_data$Location ==
             "Democratic People's Republic of Korea" ,]$region <- "North Korea"

sugar_data[sugar_data$Location =="Republic of Korea",]$region <- "South Korea"

sugar_data[sugar_data$Location =="Iran (Islamic Republic of)" ,]$region <- "Iran"

sugar_data[sugar_data$Location =="Lao People's Democratic Republic",]$region <- "Laos"

sugar_data[sugar_data$Location =="Syrian Arab Republic",]$region <- "Syria"
sugar_data[sugar_data$Location =="Czechia",]$region <- "Czech Republic"
```

Remove previous `Value` column to avoid a duplicated column:  

```{r}
polygon_sf <- polygon_sf[,names(polygon_sf) != "Value"]
```

Re-join the sugar data:  
 
```{r}
polygon_sf <- left_join(polygon_sf, sugar_data[,c("region", "Value")], 
                        by = "region")
```

\pagebreak  
  
  
  
```{r, echo = FALSE, eval = FALSE}
index <- unique(polygon_sf$region) %in% unique(sugar_data$Location)
unique(polygon_sf$region)[!index]

index2 <- unique(sugar_data$Location) %in% unique(polygon_sf$region) 
unique(sugar_data$Location)[!index2]
```
\pagebreak  
  
  
  

Re-draw the map:  

```{r, fig.cap = "Now fewer countries have data missing.", out.extra = "", eval = FALSE}
ggplot(polygon_sf) +
  geom_sf(aes(fill = Value)) 
```

The `left_join()` function will not automatically replace the values in the `Value` column; thus that column has been dropped before re-joining the sugar data values.  
  
**Excercise.** Note that there is WHO data for "Trinidad and Tobago", but that the map data has Trinidad and Tobago labelled as separate regions. 

\pagebreak  
  
  
  

## Colour Scales  
  
  
```{r, fig.cap = "Now fewer countries have data missing.", out.extra = ""}
pal <- colorspace::diverge_hcl(n = 20)

ggplot(polygon_sf) +
  theme_minimal() +
  geom_sf(aes(fill = Value)) +
  coord_sf(label_graticule = "none") +
  theme(panel.grid = element_blank()) +
  scale_fill_gradientn(colours = pal)
```

\pagebreak  
  
  
  
Try out different colour scales:  
  
```{r, fig.cap = "Now fewer countries have data missing.", out.extra = ""}
palA <- colorspace::heat_hcl(n = 20)
palB <- colorspace::terrain_hcl(n = 20)
palC <- colorspace::rainbow_hcl(n = 20)
palD <- colorspace::sequential_hcl(n = 20)

p <- ggplot(polygon_sf) + theme_minimal() +
  geom_sf(aes(fill = Value)) +
  coord_sf(label_graticule = "none") +
  theme(panel.grid = element_blank(), legend.position = "none")  
  
pA <- p %+% scale_fill_gradientn(colours = palA)
pB <- p %+% scale_fill_gradientn(colours = palB)
pC <- p %+% scale_fill_gradientn(colours = palC)
pD <- p %+% scale_fill_gradientn(colours = palD)



grid.arrange(pA, pB, pC, pD, ncol = 2)
```

\pagebreak  
  
  
  
  
## Add Text Labels to the Map  
  
  
  
The colour scale may let us seem some general patterns; however, the colour scale does not make it easy to read off a data value for any particular country.  
  
To add text labels to the map, we will want labelling points:  
  
```{r}
label_sf <- 
  reframe(group_by(polygon_sf[polygon_sf$region != "Antarctica",], region), 
          Value = unique(Value), geometry = st_union(geometry))

label_sf$centroid <- st_centroid(label_sf$geometry, of_largest_polygon = TRUE)
label_sf$point_on_surface <- st_point_on_surface(label_sf$geometry)

polygon_sf$region_label <- str_replace_all(polygon_sf$region, " ", "\n")
label_sf$region_label <- str_replace_all(label_sf$region, " ", "\n")

ggplot(polygon_sf) + geom_sf(aes(fill = Value)) +
  geom_sf_text(aes(label = Value, geometry = centroid), data = label_sf,
               size = 2, na.rm = TRUE) + theme(legend.position = "bottom")
```
This plot has a problem with overplotting of the text labels; also, black text on a blue background is relatively difficult to read.  
  
  


\pagebreak  
  
  

```{r, fig.height = 8, fig.cap = "", out.extra = ""}

pal <- colorspace::diverge_hcl(n = 20)

ggplot(polygon_sf) + theme_minimal() +
  geom_sf(aes(fill = Value)) +
  geom_sf_text(aes(label = paste(region, Value, sep = "\n"), geometry = centroid), 
               data = label_sf[!is.na(label_sf$Value), ], size = 2, na.rm = TRUE,
               lineheight = 1.05) +
  xlim(-25, 55) + ylim(-35, 75) +
  theme(legend.position = "bottom") +
  scale_fill_gradientn(colours = pal) 
```

\pagebreak  
  
  
  
## Attempts to Improve the Plot  
  
  
We can try to improve the placement of the text labels by using the `ggrepel` package; however, this will not necessarily give us flawless results.  
  
  

```{r, fig.height = 6.5, fig.cap = "", out.extra = ""}
ggplot(polygon_sf) + theme_minimal() +
  geom_sf(aes(fill = Value)) +
  geom_text_repel(stat = "sf_coordinates", aes(label = paste(region, Value, sep = "\n"), geometry = centroid), 
               data = label_sf[!is.na(label_sf$Value), ], size = 2, na.rm = TRUE,
               lineheight = 1.05, min.segment.length = 0.1, force = 1.5, max.time = 2) +
  xlim(-25, 55) + ylim(-35, 70) + theme(legend.position = "right") +
  scale_fill_gradientn(colours = pal) 
```
\pagebreak  
  
  
```{r, fig.height = 6.5, fig.cap = "", out.extra = ""}
ggplot(polygon_sf) + theme_minimal() +
  geom_sf(aes(fill = Value)) +
  geom_text_repel(stat = "sf_coordinates", aes(label = paste(region_label, Value, sep = "\n"), geometry = centroid), 
               data = label_sf[!is.na(label_sf$Value), ], size = 1.8, na.rm = TRUE,
               lineheight = 0.95, min.segment.length = 0.1, force = 0.1, force_pull = 10, max.time = 2,
               box.padding = 0.05, max.overlaps = 20) +
  xlim(-25, 55) + ylim(-35, 70) + theme(legend.position = "right") +
  scale_fill_gradientn(colours = pal) 
```
\pagebreak  
  
  
  
```{r, fig.height = 6.5, fig.cap = "", out.extra = "", echo = FALSE, eval = FALSE}
ggplot(polygon_sf) + theme_minimal() +
  geom_sf(aes(colour = Value, fill = Value, size = Value, geometry = centroid), data = label_sf, shape = 21) +
  geom_text_repel(stat = "sf_coordinates", aes(label = paste(region_label, Value, sep = "\n"), geometry = centroid), 
               data = label_sf[!is.na(label_sf$Value), ], size = 1.8, na.rm = TRUE,
               lineheight = 0.95, min.segment.length = 0.1, force = 20, force_pull = 1, max.time = 2,
               box.padding = 0.05, max.overlaps = 20) +
  xlim(-25, 55) + ylim(-35, 70) + theme(legend.position = "right") +
  scale_fill_gradientn(colours = pal, aesthetics = c("fill", "colour")) 
```

\pagebreak  
  
  
  
```{r, echo = FALSE, eval = FALSE}
ggplot(polygon_sf) + theme_minimal() +
  geom_sf(aes(fill = Value)) +
  geom_text_repel(stat = "sf_coordinates", aes(label = paste(region, Value, sep = "\n"), geometry = centroid), 
               data = label_sf[!is.na(label_sf$Value), ], size = 2, na.rm = TRUE,
               lineheight = 1.05) +
  xlim(80, 140) + ylim(-30, 50) +
  theme(legend.position = "bottom") +
  scale_fill_gradientn(colours = pal) 
```


# A Bubbleplot  
  
  
The placement of text labels with `ggrepel` is difficult enough that we might be able to do better by custom programming a label placement algorithm. Here is the result of an attempt at such an algorithm.  
  


```{r, echo = FALSE, fig.height = 8.5}
label_sf <- cbind(label_sf, st_coordinates(label_sf$centroid))
# names(label_sf)

label_sf_subset <- label_sf[(label_sf$X > -25 ) & (label_sf$X < 55) & (label_sf$Y > -35) & (label_sf$Y < 70), ]

x_values <- seq(min(label_sf_subset$X), max(label_sf_subset$X), length.out = ceiling(sqrt(nrow(label_sf_subset)))) 
y_values <- seq(min(label_sf_subset$Y) - 10, max(label_sf_subset$Y) + 25, length.out = ceiling(sqrt(nrow(label_sf_subset))))

xy_grid <- expand.grid(X = x_values, Y = rev(y_values))

nrow <- length(y_values)
ncol <- length(x_values)

regions <- character(nrow(label_sf_subset))


label_sf_subsetB <- label_sf_subset
x_start <- numeric(nrow(label_sf_subset))
y_start <- numeric(nrow(label_sf_subset))

for (i in 1:nrow(label_sf_subset)){
  a <- ((i-1) %/% nrow) + 1
  b <- ((i-1) %% ncol) + 1
  
  x0 <- xy_grid[i,]$X
  y0 <- xy_grid[i,]$Y
  
  distances <- sqrt((label_sf_subsetB$X - x0)^2 + (label_sf_subsetB$Y - y0)^2)
  
  index <- which(distances == min(distances))
  
  regions[i] <- label_sf_subsetB$region[index]
  
  x_start[i] <- label_sf_subsetB$X[index]
  y_start[i] <- label_sf_subsetB$Y[index]
  
label_sf_subsetB <- label_sf_subsetB[-index, ]
}


xy_grid <- xy_grid[1:nrow(label_sf_subset),]
xy_grid$region <- regions
xy_grid$x_start <- x_start
xy_grid$y_start <- y_start


xy_grid <- left_join(xy_grid, sugar_data[,c("region", "Value")], by = "region")

pal <- colorspace::diverge_hcl(20)

xy_grid$region_label <- paste(xy_grid$region, xy_grid$Value)
xy_grid$region_label <- str_replace_all(xy_grid$region_label, " ", "\n")

xmin <- min(xy_grid$X) - 5
xmax <- max(xy_grid$X) + 5
ymin <- min(xy_grid$Y) - 5
ymax <- max(xy_grid$Y) + 5

ggplot(xy_grid[!is.na(xy_grid$Value), ]) + theme_void() +
  geom_sf(aes(geometry = geometry), data = polygon_sf, fill = "transparent", colour = grey(0.5), linewidth = 0.5) +
  geom_segment(aes(X,Y, xend = x_start, yend = y_start), colour = "black") +
  geom_point(aes(X, Y, size = Value,fill = Value), shape = 21, colour = "black", stroke = 0.2) +
  geom_text(aes(X, Y, label = region_label), size = 2, lineheight = 1) +
  scale_colour_gradientn(colours = pal, aesthetics = c("fill", "colour")) +
  guides(colour = guide_legend(reverse = TRUE), fill =  guide_legend(reverse = TRUE), size = guide_legend(reverse = TRUE)) +
  coord_sf(xlim = c(xmin, xmax), ylim = c(ymin, ymax)) +
  scale_size(range = c(1, 14))


p <- ggplot(xy_grid[!is.na(xy_grid$Value), ]) + theme_void() +
  geom_sf(aes(geometry = geometry, fill = Value), data = polygon_sf) +
  geom_segment(aes(X,Y, xend = x_start, yend = y_start), colour = grey(0.5), alpha = 0.5) +
  geom_point(aes(X, Y, size = Value), shape = 21, colour = "black", stroke = 0.2) +
  geom_text(aes(X, Y, label = region_label), size = 2, lineheight = 1) +
  scale_colour_gradientn(colours = pal, aesthetics = c("fill", "colour")) +
  guides(colour = guide_legend(reverse = TRUE), fill =  guide_legend(reverse = TRUE), size = guide_legend(reverse = TRUE)) +
  coord_sf(xlim = c(xmin, xmax), ylim = c(ymin, ymax)) +
  scale_size(range = c(1, 14))
```

\pagebreak  
  

# The Hue-Chroma-Luminance Colour Space  
  
```{r}




```
  
  
